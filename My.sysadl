Model SysADLArchitecture;
package SysADL.types {
	value type Int {
	}
	value type Boolean {
	}
	value type String {
	}
	value type Void {
	}
	value type Real {
	}
	
	datatype Presenca {
		attributes valor : Boolean
	}
	datatype Ticket {
		attributes codigo : CodBarras hora : Hora
	}
	value type CodBarras {
	}
	value type Hora {
	}
	enum Cor {
		Verde, Amarelo, Azul, Vermelho
	}
	
	
	enum AcoesCancela {
		Abrir, Fechar
	}
	datatype Relatorio {
	}
	datatype RelatorioFinanceiro extends Relatorio {
	}
	datatype RelatorioOcupacao extends Relatorio {
	}
datatype ValorPag {
		attributes Valor : Dinheiro
	}
	value type Dinheiro {
	}
	datatype ConfPag {
		attributes valor : Boolean
	}
enum TipoVaga {
		Normal, Idoso, Deficiente
	}
	enum StatusVaga {
		"Disponível", Ocupada
	}
}
Requirement GerenciarVagas ( 01 ) {
	text = "O sistema deve monitorar cada uma das vagas do estacionamento e sinalizar o status da vaga por meio de lâmpadas, diferenciando as vagas destinadas a idosos e deficientes físicos das demais"
Requirement SinalizarStatusdaVaga ( 01.1 ) {
	text = "O status da vaga deve ser representado pela cor da lâmpada associada a ela, a cor vermelha indica que a vaga está ocupada, a cor verde indica que a vaga está disponível, a cor amarela indica que a vaga está disponível e que é destinada a idosos, a cor azul indica que a vaga está disponível e que é destinada à deficientes físicos."
}
	Requirement DetectarStatusdaVaga ( 01.2 ) {
	text = "O sistema deve detectar para cada vaga do estacionamento se existe ou não um veículo estacionado"
}
Requirement SinalizarQuantidadedeVagasDisponiveis ( 1.3 ) {
		text =
		"O sistema deve indicar em painéis a quantidade de vagas disponíveis em cada ala do estacionamento."
	}
}
Requirement GerenciarEntradadeVeiculos ( 2.0 ) {
	text =
	"O sistema deve controlar a entrada de veículos por meio de uma cancela eletrônica. Um ticket com código de barras deve ser impresso para cada motorista antes de  o mesmo entrar no estacionamento."
	Requirement ImprimirTicket ( 2.1 ) {
		text =
		"Antes de o motorista entrar no estacionamento um ticket com código de barras deve ser impresso e recolhido pelo motorista. Associado ao código de barras impresso no ticket o sistema deve armazenar a hora em que o ticket foi gerado."
	}
}
Requirement GerenciarSaidaVeiculos ( 3.0 ) {
	text =
	"O sistema deve gerenciar a saída de veículos por meio de uma cancela eletrônica. Os veículos poderão deixar o estacionamento apenas após o pagamento da taxa de estacionamento."
	Requirement LerTicket ( 3.1 ) {
		text =
		"A partir da leitura do código de barras impresso no ticket o sistema deve recuperar todas as informações associadas ao ticket (horário de entrada\r\nno estacionamento, valor da taxa de estacionamento,  se a taxa foi ou não paga, se foi paga o horário de pagamento )."
	}
}
Requirement GerarRelatorio ( 7.0 ) {
	text =
	"O sistema deve permitir ao gerente consultar a ocupação do estacionamento e gerar relatórios financeiros."
	Requirement GerarRelatorioFinanceiro ( 7.1 ) {
		text =
		"O sistema deve permitir ao gerente gerar relatórios que detalhem a arrecadação do estacionamento em períodos de tempo informados pelo gerente."
	}
	Requirement ConsultarOcupacao ( 7.2 ) {
		text =
		"O sistema deve permitir ao gerente consultar a ocupação do estacionamento por dia, hora, semana e mês."
	}
}

Requirement GerenciarPagamento ( 6.0 ) {
	text =
	"O sistema deve permitir ao usuário realizar o pagamento da taxa de estacionamento. O pagamento deve ser calculado com base no tempo em que o veículo esteve no estacionamento."
	Requirement RealizarPagamento ( 6.1 ) {
		text =
		"O sistema deve permitir ao usuário realizar o pagamento em caixas automáticos com cartão ou dinheiro."
	}
}
Requirement AbrirCancelaEletronica ( 5.0 ) {
	text =
	"A cancela eletrônica deve abrir automaticamente após o motorista recolher o ticket impresso na entrada e no momento em que o motorista apresentar o ticket devidamente paga na saída do estacionamento"
}
Requirement DetectarVeivulo ( 4.0 ) {
	text =
	"Ao se se aproximar com o veículo da cancela eletrônica a presença do veículo deve ser detectada de forma automática."
}
Requirement AbrirCancelaEmergencial ( 8.0 ) {
	text =
	"Em casos de emergência o operador do estacionamento poderá abrir a cancela de emergência."
}
package Components {
import Ports;
	import Connectors;
	import SysADL.types;
	component def ControladorCorCP {
		
	ports p12 : Ports.PresencaIPT {
		}
		p16 : Ports.TipoVagaIPT {
		}
		p13 : Ports.CorOPT {
		}
	}
component def SensorPresencaCP {
		ports p11 : Ports.PresencaOPT {
		}
	}
	component def LedVagaCP {
	ports P14 : Ports.CorIPT {
		}
	}
	component def GerenciadorEstacionamento {
		configuration {
			components:
			newGerenciadorVagasCP : GerenciadorVagasCP {
			}
			newGerenciadorSaidaCP : GerenciadorSaidaCP {
			}
			newGerenciadorEntradaCP : GerenciadorEntradaCP {
			}
			newControladorCancelaEmergencialCP : ControladorCancelaEmergencialCP {
			}
		}
	}
	component def PainelLedCP {
		ports p18 : Ports.QtVagasIPT {
		}
	}
	component def CancelaCP {
		ports p10 : Ports.ComCancelaIPT {
		}
	}
	component def ImpressoraTicketCP {
		ports p12 : Ports.PresencaIPT {
		}
		p1 : Ports.TicketOPT {
		}
		p10 : Ports.ComCancelaOPT {
		}
	}
	boundary component def LeitorTicketCP {
		ports pcod : Ports.CodigoTicketIPT {
		}
		p1 : Ports.TicketOPT {
		}
	}
	boundary component def CaixaPagCP {
		ports p6 : Ports.ValorPagIPT {
		}
		ppag : Ports.PagamentoIPT {
		}
		p7 : Ports.ConfPagOPT {
		}
	}
	component def ControladorCancelaCN {
		ports p8 : Ports.ConfPagIPT {
		}
		p9 : Ports.ComCancelaOPT {
		}
	}
	component def BdVagaCP {
		ports p15 : Ports.TipoVagaOPT {
		}
		p17 : Ports.QtVagasOPT {
		}
	}
	component def CalculadorPrecoPagamentoCP {
		ports p5 : Ports.ValorPagOPT {
		}
		p2 : Ports.TicketIPT {
		}
	}
	component def GerenciadorSaidaCP {
		configuration {
			components:
			newLeitorTicketCP : LeitorTicketCP {
			}
			newControladorCancelaCN : ControladorCancelaCN {
			}
			newCalculadorPrecoPagamentoCP : CalculadorPrecoPagamentoCP {
			}
			newCancelaCP : CancelaCP {
			}
			newCaixaPagCP : CaixaPagCP {
			}
		}
	}
	component def GerenciadorEntradaCP {
		configuration {
			components:
			newImpressoraTicketCP : ImpressoraTicketCP {
			}
			newCancelaCP : CancelaCP {
			}
		}
	}
	boundary component def ControladorCancelaEmergencialCP {
		ports p10 : Ports.ComCancelaIPT {
		}
		p9 : Ports.ComCancelaOPT {
		}
	}
	component def GerenciadorVagasCP {
		configuration {
			components:
			newSensorPresencaCP : SensorPresencaCP {
			}
			newBdVagaCP : BdVagaCP {
			}
			newControladorCorCP : ControladorCorCP {
			}
			newLedVagaCP : LedVagaCP {
			}
			newPainelLedCP : PainelLedCP {
			}
		}
	}
}
package Connectors {
import SysADL.types;
	import Ports;
connector def CodigoTickerCNT {
		participants ~ p3 : Ports.CodigoTicketOPT {
		}
		~ p4 : Ports.CodigoTicketIPT {
		}
		flows SysADL.types.CodBarras from p3 to p4
	}
	
	connector def RelatorioCNT {
		participants ~ p19 : Ports.RelatorioOPT {
		}
		~ p20 : Ports.RelatorioIPT {
		}
	flows SysADL.types.Relatorio from p19 to p20
	}
	connector def PresencaCNT {
		participants ~ p11 : Ports.PresencaOPT {
		}
		~ p12 : Ports.PresencaIPT {
		}
		flows SysADL.types.Presenca from p11 to p12
	}
	connector def ComCancelaCNT {
		participants ~ p9 : Ports.ComCancelaOPT {
		}
		~ p10 : Ports.ComCancelaIPT {
		}
		flows 
	SysADL.types.AcoesCancela from p9 to p10
	}
	connector def TicketCNT {
		participants ~ p1 : Ports.TicketOPT {
		}
		~ p2 : Ports.TicketIPT {
		}
		flows 
	SysADL.types.Ticket from p1 to p2
	}
	connector def ValorPagCNT {
		participants ~ p5 : Ports.ValorPagOPT {
		}
		~ p6 : Ports.ValorPagIPT {
		}
		flows 
	SysADL.types.ValorPag from p5 to p6
	}
connector def ConfPagCNT {
		participants ~ p7 : Ports.ConfPagOPT {
		}
		~ p8 : Ports.ConfPagIPT {
		}
		flows SysADL.types.ConfPag from p7 to p8
	}
	connector def CorCNT {
		participants ~ p13 : Ports.CorOPT {
		}
		~ p14 : Ports.CorIPT {
		}
		flows SysADL.types.Cor from p13 to p14
	}
	connector def QtVagasCNT {
		participants ~ p17 : Ports.QtVagasOPT {
		}
		~ p18 : Ports.QtVagasIPT {
		}
		flows SysADL.types.Int from p17 to p18
	}
	connector def TipoVagaCNT {
		participants ~ p15 : Ports.TipoVagaOPT {
		}
		~ p16 : Ports.TipoVagaIPT {
		}
		flows SysADL.types.TipoVaga from p15 to p16
	}
}
package Ports {
import SysADL.types;
	
	
	port def PresencaIPT {
		flow in SysADL.types.Presenca
	}
	port def PresencaOPT {
		flow out SysADL.types.Presenca
	}
	port def ComCancelaIPT {
		flow in SysADL.types.AcoesCancela
	}
	port def ComCancelaOPT {
		flow out SysADL.types.AcoesCancela
	}
	port def RelatorioIPT {
		flow in SysADL.types.Relatorio
	}
	port def RelatorioOPT {
		flow out SysADL.types.Relatorio
	}
port def ValorPagIPT {
		flow in SysADL.types.ValorPag
	}
	port def ValorPagOPT {
		flow out SysADL.types.ValorPag
	}
	port def CodigoTicketIPT {
		flow in SysADL.types.CodBarras
	}
	port def CodigoTicketOPT {
		flow out SysADL.types.CodBarras
	}
port def TicketIPT {
		flow in SysADL.types.Ticket
	}
	
	
	port def TicketOPT {
		flow out SysADL.types.Ticket
	}
port def QtVagasIPT {
		flow in SysADL.types.Int
	}
	port def QtVagasOPT {
		flow out SysADL.types.Int
	}
	port def CorIPT {
		flow in SysADL.types.Cor
	}
	port def CorOPT {
		flow out SysADL.types.Cor
	}
port def PagamentoIPT {
		flow in SysADL.types.Dinheiro
	}
	port def ConfPagOPT {
		flow out SysADL.types.ConfPag
	}
	port def ConfPagIPT {
		flow in SysADL.types.ConfPag
	}
	port def TipoVagaIPT {
		flow in SysADL.types.TipoVaga
	}
	port def TipoVagaOPT {
		flow out SysADL.types.TipoVaga
	}
}